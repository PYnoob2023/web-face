<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D äººè„¸ç‚¹äº‘ - æç®€æ¨¡å¼</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: white;
        }
        
        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* FPSæ˜¾ç¤º - æç®€ */
        #fps-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 14px;
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            background: rgba(0, 0, 0, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            backdrop-filter: blur(5px);
            z-index: 100;
            user-select: none;
        }
        
        .fps-label {
            color: #888;
            margin-right: 5px;
        }
        
        /* ä½¿ç”¨è¯´æ˜ - æç®€ */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 12px;
            color: #aaa;
            backdrop-filter: blur(5px);
            z-index: 100;
            max-width: 90%;
            text-align: center;
            user-select: none;
            transition: opacity 0.3s;
        }
        
        .instruction-item {
            display: inline-block;
            margin: 0 10px;
        }
        
        .instruction-key {
            color: #00ff88;
            font-weight: bold;
            margin-right: 4px;
        }
        
        /* æ‘„åƒå¤´æƒé™å¼¹çª— - ç®€åŒ– */
        #camera-permission {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 25px;
            width: 90%;
            max-width: 400px;
            text-align: center;
            backdrop-filter: blur(20px);
            z-index: 1000;
        }
        
        .permission-title {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .permission-text {
            color: #ccc;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 20px;
        }
        
        #start-camera {
            background: #00ff88;
            color: #000;
            font-weight: bold;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            #fps-display {
                top: 15px;
                right: 15px;
                font-size: 12px;
                padding: 4px 8px;
            }
            
            #instructions {
                bottom: 15px;
                padding: 8px 12px;
                font-size: 11px;
            }
            
            .instruction-item {
                margin: 0 6px;
            }
        }
        
        @media (max-width: 480px) {
            #instructions {
                font-size: 10px;
                padding: 6px 10px;
            }
            
            .instruction-item {
                margin: 0 4px;
            }
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas"></canvas>

    <!-- FPSæ˜¾ç¤º -->
    <div id="fps-display">
        <span class="fps-label">FPS:</span>
        <span id="fps-value">0</span>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜ -->
    <div id="instructions">
        <div class="instruction-item">
            <span class="instruction-key">è§¦æ‘¸/é¼ æ ‡</span>
            <span>æ—‹è½¬</span>
        </div>
        <div class="instruction-item">
            <span class="instruction-key">åŒæŒ‡/æ»šè½®</span>
            <span>ç¼©æ”¾</span>
        </div>
        <div class="instruction-item">
            <span class="instruction-key">åŒå‡»</span>
            <span>é‡ç½®</span>
        </div>
    </div>

    <!-- æ‘„åƒå¤´æƒé™å¼¹çª— -->
    <div id="camera-permission">
        <div class="permission-title">ğŸ“± äººè„¸ç‚¹äº‘æ£€æµ‹</div>
        <div class="permission-text">
            éœ€è¦è®¿é—®æ‚¨çš„æ‘„åƒå¤´ä»¥è¿›è¡Œ3Dé¢éƒ¨ç‚¹äº‘é‡å»ºã€‚<br>
            æ‰€æœ‰å¤„ç†å‡åœ¨æœ¬åœ°å®Œæˆï¼Œæ•°æ®ä¸ä¼šä¸Šä¼ ã€‚
        </div>
        <button id="start-camera">å¼€å§‹æ£€æµ‹</button>
    </div>

    <script>
    // ä¸»åº”ç”¨ç¨‹åºç±» - æç®€ç‰ˆæœ¬
    class FacePointCloudApp {
        constructor() {
            // æ£€æµ‹è®¾å¤‡
            this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // çŠ¶æ€å˜é‡
            this.isRunning = false;
            this.isPaused = false;
            
            // æ€§èƒ½ç»Ÿè®¡
            this.frameCount = 0;
            this.lastFpsTime = 0;
            this.fps = 0;
            
            // 3Dåœºæ™¯å‚æ•°
            this.cameraDistance = this.isMobile ? 4.0 : 3.0;
            this.rotationX = 0.0;
            this.rotationY = 0.0;
            this.isDragging = false;
            
            // ç‚¹äº‘å‚æ•°
            this.basePointSize = 2.5;
            this.spacingMultiplier = 1.5;
            
            // é¢œè‰²ç³»ç»Ÿ
            this.colors = this.createColorSystem();
            
            // DOMå…ƒç´ 
            this.canvas = document.getElementById('webgl-canvas');
            this.fpsElement = document.getElementById('fps-value');
            this.instructions = document.getElementById('instructions');
            
            // åˆå§‹åŒ–
            this.initThreeJS();
            this.initEventListeners();
            
            console.log("ğŸš€ 3Dé¢éƒ¨ç‚¹äº‘ - æç®€æ¨¡å¼");
        }
        
        // åˆ›å»ºé¢œè‰²ç³»ç»Ÿ
        createColorSystem() {
            return {
                face_oval: 0x00b4ff,
                lips: 0xff3366,
                eyes: 0x00ff88,
                eyebrows: 0xffcc00,
                nose: 0xff6600,
                default: 0xcccccc
            };
        }
        
        getColor(index) {
            if (index < 17) return this.colors.face_oval;
            if (index >= 61 && index < 97) return this.colors.lips;
            if (index >= 33 && index < 47) return this.colors.eyes;
            if (index >= 263 && index < 277) return this.colors.eyes;
            if (index >= 105 && index < 117) return this.colors.eyebrows;
            if (index >= 285 && index < 297) return this.colors.eyebrows;
            if ((index >= 168 && index < 198) || [1,2,3,4,5,6].includes(index)) return this.colors.nose;
            return this.colors.default;
        }
        
        // åˆå§‹åŒ–Three.js
        initThreeJS() {
            try {
                // åœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                
                // ç›¸æœº
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
                this.camera.position.set(0, 0, this.cameraDistance);
                
                // æ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: false,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                
                // ç‚¹äº‘
                this.pointsGeometry = new THREE.BufferGeometry();
                this.pointsMaterial = new THREE.PointsMaterial({
                    size: this.basePointSize,
                    vertexColors: true,
                    sizeAttenuation: false,
                    transparent: false,
                    depthTest: true
                });
                
                this.points = new THREE.Points(this.pointsGeometry, this.pointsMaterial);
                this.scene.add(this.points);
                
                console.log("âœ… Three.jsåˆå§‹åŒ–å®Œæˆ");
                
            } catch (error) {
                console.error("âŒ Three.jsåˆå§‹åŒ–å¤±è´¥:", error);
                alert("WebGLåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
            }
        }
        
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        initEventListeners() {
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // é¼ æ ‡äº‹ä»¶
            this.canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.rotationY -= deltaX * 0.5;
                this.rotationX += deltaY * 0.5;
                this.rotationX = Math.max(-90, Math.min(90, this.rotationX));
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                this.isDragging = false;
            });
            
            // æ»šè½®ç¼©æ”¾
            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                this.cameraDistance += e.deltaY * 0.005;
                this.cameraDistance = Math.max(1.0, Math.min(10.0, this.cameraDistance));
            });
            
            // è§¦æ‘¸äº‹ä»¶
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastMouseX = e.touches[0].clientX;
                    this.lastMouseY = e.touches[0].clientY;
                    this.touchStartRotation = { x: this.rotationX, y: this.rotationY };
                }
                
                if (e.touches.length === 2) {
                    this.isDragging = false;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    this.lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            this.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 1 && this.isDragging) {
                    const deltaX = e.touches[0].clientX - this.lastMouseX;
                    const deltaY = e.touches[0].clientY - this.lastMouseY;
                    
                    this.rotationY = this.touchStartRotation.y - deltaX * 0.5;
                    this.rotationX = this.touchStartRotation.x + deltaY * 0.5;
                    this.rotationX = Math.max(-90, Math.min(90, this.rotationX));
                    
                    this.lastMouseX = e.touches[0].clientX;
                    this.lastMouseY = e.touches[0].clientY;
                }
                
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const touchDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    const zoomDelta = (touchDistance - this.lastTouchDistance) * 0.01;
                    this.cameraDistance -= zoomDelta;
                    this.cameraDistance = Math.max(1.0, Math.min(10.0, this.cameraDistance));
                    
                    this.lastTouchDistance = touchDistance;
                }
            });
            
            this.canvas.addEventListener('touchend', () => {
                this.isDragging = false;
            });
            
            // åŒå‡»é‡ç½®
            this.canvas.addEventListener('dblclick', () => {
                this.cameraDistance = this.isMobile ? 4.0 : 3.0;
                this.rotationX = 0.0;
                this.rotationY = 0.0;
            });
            
            // å¼€å§‹æ‘„åƒå¤´æŒ‰é’®
            document.getElementById('start-camera').addEventListener('click', () => {
                this.startCamera();
            });
            
            // ç©ºæ ¼æš‚åœ/ç»§ç»­
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    this.isPaused = !this.isPaused;
                }
            });
            
            // éšè—/æ˜¾ç¤ºè¯´æ˜
            this.instructions.addEventListener('click', () => {
                this.instructions.style.opacity = this.instructions.style.opacity === '0.3' ? '1' : '0.3';
            });
        }
        
        // å¼€å§‹æ‘„åƒå¤´
        async startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: this.isMobile ? 480 : 640 },
                        height: { ideal: this.isMobile ? 640 : 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 24 }
                    },
                    audio: false
                });
                
                this.videoElement = document.createElement('video');
                this.videoElement.srcObject = stream;
                this.videoElement.autoplay = true;
                this.videoElement.playsInline = true;
                this.videoElement.muted = true;
                this.videoElement.style.display = 'none';
                document.body.appendChild(this.videoElement);
                
                await new Promise((resolve) => {
                    this.videoElement.onloadedmetadata = () => {
                        this.videoElement.play();
                        resolve();
                    };
                });
                
                document.getElementById('camera-permission').style.display = 'none';
                
                await this.initMediaPipe();
                this.start();
                
            } catch (error) {
                console.error("æ‘„åƒå¤´è®¿é—®å¤±è´¥:", error);
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®");
            }
        }
        
        // åˆå§‹åŒ–MediaPipe
        async initMediaPipe() {
            this.faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            this.faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            this.faceMesh.onResults(this.handleFaceResults.bind(this));
            
            // å¼€å§‹å¤„ç†è§†é¢‘
            const processFrame = async () => {
                if (!this.isRunning || this.isPaused || !this.videoElement) return;
                
                try {
                    if (this.videoElement.readyState >= 2) {
                        await this.faceMesh.send({image: this.videoElement});
                    }
                    requestAnimationFrame(processFrame);
                } catch (error) {
                    console.error("è§†é¢‘å¤„ç†é”™è¯¯:", error);
                    requestAnimationFrame(processFrame);
                }
            };
            
            this.isRunning = true;
            processFrame();
        }
        
        // å¤„ç†é¢éƒ¨æ£€æµ‹ç»“æœ
        handleFaceResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                return;
            }
            
            const faceLandmarks = results.multiFaceLandmarks[0];
            const landmarks3D = [];
            
            faceLandmarks.forEach(lm => {
                const x = (0.5 - lm.x) * 2.0 * this.spacingMultiplier;
                const y = (0.5 - lm.y) * 2.0 * this.spacingMultiplier;
                const z = -lm.z * 1.5 * this.spacingMultiplier;
                landmarks3D.push([x, y, z]);
            });
            
            this.updatePointCloud(landmarks3D);
        }
        
        // æ›´æ–°ç‚¹äº‘
        updatePointCloud(landmarks) {
            const positions = new Float32Array(landmarks.length * 3);
            const colors = new Float32Array(landmarks.length * 3);
            
            landmarks.forEach((point, index) => {
                positions[index * 3] = point[0];
                positions[index * 3 + 1] = point[1];
                positions[index * 3 + 2] = point[2];
                
                const color = this.getColor(index);
                colors[index * 3] = ((color >> 16) & 255) / 255;
                colors[index * 3 + 1] = ((color >> 8) & 255) / 255;
                colors[index * 3 + 2] = (color & 255) / 255;
            });
            
            this.pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            this.pointsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }
        
        // åŠ¨ç”»å¾ªç¯
        animate() {
            const now = performance.now();
            
            // æ›´æ–°FPS
            if (this.lastFpsTime === 0) this.lastFpsTime = now;
            this.frameCount++;
            
            if (now - this.lastFpsTime >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFpsTime = now;
                this.fpsElement.textContent = Math.round(this.fps);
            }
            
            // æ›´æ–°ç›¸æœºä½ç½®
            const radX = THREE.MathUtils.degToRad(this.rotationX);
            const radY = THREE.MathUtils.degToRad(this.rotationY);
            
            const cameraX = this.cameraDistance * Math.sin(radY) * Math.cos(radX);
            const cameraY = this.cameraDistance * Math.sin(radX);
            const cameraZ = this.cameraDistance * Math.cos(radY) * Math.cos(radX);
            
            this.camera.position.set(cameraX, cameraY, cameraZ);
            this.camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“
            this.renderer.render(this.scene, this.camera);
            
            requestAnimationFrame(this.animate.bind(this));
        }
        
        // å¯åŠ¨åº”ç”¨
        start() {
            this.animate();
            console.log("ğŸš€ åº”ç”¨å·²å¯åŠ¨");
        }
    }

    // é¡µé¢åŠ è½½
    window.addEventListener('DOMContentLoaded', () => {
        new FacePointCloudApp();
    });
    </script>
</body>
</html>
