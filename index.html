<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D äººè„¸ç‚¹äº‘ - æ¸…æ™°ç‚¹äº‘ç‰ˆ</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: white;
        }
        
        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        /* FPSæ˜¾ç¤º */
        #fps-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 14px;
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            z-index: 100;
            user-select: none;
        }
        
        /* ä½¿ç”¨è¯´æ˜ */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 13px;
            color: #ccc;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-width: 90%;
            text-align: center;
            user-select: none;
        }
        
        .instruction-item {
            display: inline-block;
            margin: 0 8px;
        }
        
        .instruction-key {
            color: #00ff88;
            font-weight: bold;
            margin-right: 4px;
        }
        
        /* æ‘„åƒå¤´æƒé™å¼¹çª— */
        #camera-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 1000;
            text-align: center;
        }
        
        .permission-content {
            background: rgba(20, 20, 25, 0.9);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }
        
        .permission-title {
            color: #00ff88;
            font-size: 22px;
            margin-bottom: 20px;
        }
        
        .permission-text {
            color: #ccc;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 25px;
        }
        
        #start-camera {
            background: #00ff88;
            color: #000;
            font-weight: bold;
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
        }
        
        @media (max-width: 768px) {
            #fps-display {
                top: 10px;
                right: 10px;
                font-size: 12px;
                padding: 6px 12px;
            }
            
            #instructions {
                bottom: 10px;
                padding: 10px 15px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas"></canvas>

    <!-- FPSæ˜¾ç¤º -->
    <div id="fps-display">
        <span>FPS: </span>
        <span id="fps-value">0</span>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜ -->
    <div id="instructions">
        <div class="instruction-item">
            <span class="instruction-key">æ‹–åŠ¨</span>
            <span>æ—‹è½¬</span>
        </div>
        <div class="instruction-item">
            <span class="instruction-key">ç¼©æ”¾</span>
            <span>è°ƒæ•´è·ç¦»</span>
        </div>
        <div class="instruction-item">
            <span class="instruction-key">åŒå‡»</span>
            <span>é‡ç½®</span>
        </div>
    </div>

    <!-- æ‘„åƒå¤´æƒé™å¼¹çª— -->
    <div id="camera-permission">
        <div class="permission-content">
            <div class="permission-title">äººè„¸ç‚¹äº‘æ£€æµ‹</div>
            <div class="permission-text">
                éœ€è¦è®¿é—®æ‚¨çš„æ‘„åƒå¤´<br>
                æ‰€æœ‰å¤„ç†å‡åœ¨æœ¬åœ°å®Œæˆ
            </div>
            <button id="start-camera">å¼€å§‹æ£€æµ‹</button>
        </div>
    </div>

    <script>
    class FacePointCloudApp {
        constructor() {
            // è®¾å¤‡æ£€æµ‹
            this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // çŠ¶æ€
            this.isRunning = false;
            this.isPaused = false;
            
            // æ€§èƒ½
            this.frameCount = 0;
            this.lastFpsTime = 0;
            this.fps = 0;
            
            // 3Då‚æ•° - ä¿®å¤ç‚¹äº‘æ¸…æ™°åº¦çš„å…³é”®å‚æ•°
            this.cameraDistance = 3.0;
            this.rotationX = 0.0;
            this.rotationY = 0.0;
            this.isDragging = false;
            
            // ğŸ¯ å…³é”®ï¼šç‚¹äº‘æ¸…æ™°åº¦å‚æ•°
            this.basePointSize = 2.5;           // å°ç‚¹ï¼Œéé¢
            this.spacingMultiplier = 1.5;       // å¢åŠ ç‚¹é—´è·
            
            // DOMå…ƒç´ 
            this.canvas = document.getElementById('webgl-canvas');
            this.fpsElement = document.getElementById('fps-value');
            
            // åˆå§‹åŒ–
            this.initThreeJS();
            this.initEventListeners();
        }
        
        // ğŸ¯ å…³é”®ï¼šåˆå§‹åŒ–Three.js - ç¡®ä¿ç‚¹äº‘æ¸…æ™°
        initThreeJS() {
            try {
                // åœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                
                // ç›¸æœº
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
                this.camera.position.set(0, 0, this.cameraDistance);
                
                // ğŸ¯ å…³é”®ï¼šæ¸²æŸ“å™¨è®¾ç½® - ç¡®ä¿æ¸…æ™°ç‚¹
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: false,           // âŒ ç¦ç”¨æŠ—é”¯é½¿
                    alpha: false,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(1); // âŒ å›ºå®šåƒç´ æ¯”ï¼Œé˜²æ­¢æ¨¡ç³Š
                
                // ğŸ¯ å…³é”®ï¼šç‚¹äº‘æè´¨ - ç¡®ä¿æ¸…æ™°å°ç‚¹
                this.pointsGeometry = new THREE.BufferGeometry();
                this.pointsMaterial = new THREE.PointsMaterial({
                    size: this.basePointSize,   // å°ç‚¹
                    vertexColors: true,
                    sizeAttenuation: false,     // âŒ ç¦ç”¨å¤§å°è¡°å‡
                    transparent: false,         // âŒ ç¦ç”¨é€æ˜
                    opacity: 1.0,              // å®Œå…¨ä¸é€æ˜
                    depthWrite: true,
                    depthTest: true,
                    blending: THREE.NormalBlending // âŒ æ­£å¸¸æ··åˆï¼Œä¸å åŠ 
                });
                
                // åˆ›å»ºç‚¹äº‘
                this.points = new THREE.Points(this.pointsGeometry, this.pointsMaterial);
                this.scene.add(this.points);
                
                console.log("âœ… Three.jsåˆå§‹åŒ–å®Œæˆ - æ¸…æ™°ç‚¹äº‘æ¨¡å¼");
                
            } catch (error) {
                console.error("âŒ Three.jsåˆå§‹åŒ–å¤±è´¥:", error);
                alert("WebGLåˆå§‹åŒ–å¤±è´¥");
            }
        }
        
        initEventListeners() {
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // è§¦æ‘¸äº‹ä»¶
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastMouseX = e.touches[0].clientX;
                    this.lastMouseY = e.touches[0].clientY;
                    this.touchStartRotation = { x: this.rotationX, y: this.rotationY };
                }
            });
            
            this.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && this.isDragging) {
                    const deltaX = e.touches[0].clientX - this.lastMouseX;
                    const deltaY = e.touches[0].clientY - this.lastMouseY;
                    
                    this.rotationY = this.touchStartRotation.y - deltaX * 0.5;
                    this.rotationX = this.touchStartRotation.x + deltaY * 0.5;
                    this.rotationX = Math.max(-90, Math.min(90, this.rotationX));
                    
                    this.lastMouseX = e.touches[0].clientX;
                    this.lastMouseY = e.touches[0].clientY;
                }
            });
            
            this.canvas.addEventListener('touchend', () => {
                this.isDragging = false;
            });
            
            // é¼ æ ‡äº‹ä»¶
            this.canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!this.isDragging) return;
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.rotationY -= deltaX * 0.5;
                this.rotationX += deltaY * 0.5;
                this.rotationX = Math.max(-90, Math.min(90, this.rotationX));
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                this.isDragging = false;
            });
            
            // æ»šè½®
            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                this.cameraDistance += e.deltaY * 0.005;
                this.cameraDistance = Math.max(1.0, Math.min(10.0, this.cameraDistance));
            });
            
            // åŒå‡»é‡ç½®
            this.canvas.addEventListener('dblclick', () => {
                this.cameraDistance = 3.0;
                this.rotationX = 0.0;
                this.rotationY = 0.0;
            });
            
            // å¼€å§‹æŒ‰é’®
            document.getElementById('start-camera').addEventListener('click', () => {
                this.startCamera();
            });
        }
        
        async startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                // åˆ›å»ºè§†é¢‘å…ƒç´ 
                this.videoElement = document.createElement('video');
                this.videoElement.srcObject = stream;
                this.videoElement.autoplay = true;
                this.videoElement.playsInline = true;
                this.videoElement.muted = true;
                this.videoElement.style.display = 'none';
                document.body.appendChild(this.videoElement);
                
                await new Promise((resolve) => {
                    this.videoElement.onloadedmetadata = () => {
                        this.videoElement.play();
                        resolve();
                    };
                });
                
                document.getElementById('camera-permission').style.display = 'none';
                await this.initMediaPipe();
                this.start();
                
            } catch (error) {
                console.error("æ‘„åƒå¤´è®¿é—®å¤±è´¥:", error);
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´");
            }
        }
        
        async initMediaPipe() {
            this.faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            this.faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            this.faceMesh.onResults(this.handleFaceResults.bind(this));
            
            // å¼€å§‹å¤„ç†
            const processFrame = async () => {
                if (!this.isRunning || this.isPaused || !this.videoElement) return;
                
                try {
                    if (this.videoElement.readyState >= 2) {
                        await this.faceMesh.send({image: this.videoElement});
                    }
                    requestAnimationFrame(processFrame);
                } catch (error) {
                    requestAnimationFrame(processFrame);
                }
            };
            
            this.isRunning = true;
            processFrame();
        }
        
        handleFaceResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return;
            
            const faceLandmarks = results.multiFaceLandmarks[0];
            this.updatePointCloud(faceLandmarks);
        }
        
        // æ›´æ–°ç‚¹äº‘
        updatePointCloud(landmarks) {
            const positions = new Float32Array(landmarks.length * 3);
            const colors = new Float32Array(landmarks.length * 3);
            
            landmarks.forEach((landmark, index) => {
                // ğŸ¯ å…³é”®ï¼šåº”ç”¨é—´è·å¢å¼º
                const x = (0.5 - landmark.x) * 2.0 * this.spacingMultiplier;
                const y = (0.5 - landmark.y) * 2.0 * this.spacingMultiplier;
                const z = -landmark.z * 1.5 * this.spacingMultiplier;
                
                positions[index * 3] = x;
                positions[index * 3 + 1] = y;
                positions[index * 3 + 2] = z;
                
                // é¢œè‰²ç¼–ç 
                let color;
                if (index < 17) color = 0x00b4ff;
                else if (index >= 61 && index < 97) color = 0xff3366;
                else if ((index >= 33 && index < 47) || (index >= 263 && index < 277)) color = 0x00ff88;
                else if ((index >= 105 && index < 117) || (index >= 285 && index < 297)) color = 0xffcc00;
                else if ((index >= 168 && index < 198) || [1,2,3,4,5,6].includes(index)) color = 0xff6600;
                else color = 0xcccccc;
                
                colors[index * 3] = ((color >> 16) & 255) / 255;
                colors[index * 3 + 1] = ((color >> 8) & 255) / 255;
                colors[index * 3 + 2] = (color & 255) / 255;
            });
            
            if (!this.pointsGeometry.attributes.position) {
                this.pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.pointsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            } else {
                this.pointsGeometry.attributes.position.array = positions;
                this.pointsGeometry.attributes.color.array = colors;
                this.pointsGeometry.attributes.position.needsUpdate = true;
                this.pointsGeometry.attributes.color.needsUpdate = true;
            }
        }
        
        animate() {
            const now = performance.now();
            
            // æ›´æ–°FPS
            if (this.lastFpsTime === 0) this.lastFpsTime = now;
            this.frameCount++;
            
            if (now - this.lastFpsTime >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFpsTime = now;
                this.fpsElement.textContent = Math.round(this.fps);
            }
            
            // æ›´æ–°ç›¸æœº
            const radX = THREE.MathUtils.degToRad(this.rotationX);
            const radY = THREE.MathUtils.degToRad(this.rotationY);
            
            const cameraX = this.cameraDistance * Math.sin(radY) * Math.cos(radX);
            const cameraY = this.cameraDistance * Math.sin(radX);
            const cameraZ = this.cameraDistance * Math.cos(radY) * Math.cos(radX);
            
            this.camera.position.set(cameraX, cameraY, cameraZ);
            this.camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“
            this.renderer.render(this.scene, this.camera);
            requestAnimationFrame(this.animate.bind(this));
        }
        
        start() {
            this.animate();
        }
    }

    window.addEventListener('DOMContentLoaded', () => {
        new FacePointCloudApp();
    });
    </script>
</body>
</html>
