<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D äººè„¸ç‚¹äº‘ - è‡ªé€‚åº”å±…ä¸­ç‰ˆ</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: white;
        }
        
        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        /* åˆ†è¾¨ç‡ä¿¡æ¯æ˜¾ç¤º */
        #resolution-info {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            color: #888;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            user-select: none;
        }
        
        /* FPSæ˜¾ç¤º */
        #fps-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 14px;
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            z-index: 100;
            user-select: none;
        }
        
        /* ä½¿ç”¨è¯´æ˜ */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 13px;
            color: #ccc;
            z-index: 100;
            max-width: 90%;
            text-align: center;
            user-select: none;
        }
        
        .instruction-item {
            display: inline-block;
            margin: 0 8px;
        }
        
        .instruction-key {
            color: #00ff88;
            font-weight: bold;
            margin-right: 4px;
        }
        
        /* æ‘„åƒå¤´æƒé™å¼¹çª— */
        #camera-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 1000;
            text-align: center;
        }
        
        .permission-content {
            background: rgba(20, 20, 25, 0.9);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }
        
        .permission-title {
            color: #00ff88;
            font-size: 22px;
            margin-bottom: 20px;
        }
        
        .permission-text {
            color: #ccc;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 25px;
        }
        
        #start-camera {
            background: #00ff88;
            color: #000;
            font-weight: bold;
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
        }
        
        @media (max-width: 768px) {
            #resolution-info, #fps-display {
                top: 10px;
                font-size: 10px;
                padding: 6px 10px;
            }
            
            #resolution-info {
                left: 10px;
            }
            
            #instructions {
                bottom: 10px;
                padding: 10px 15px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas"></canvas>

    <!-- åˆ†è¾¨ç‡ä¿¡æ¯ -->
    <div id="resolution-info">
        <div>å±å¹•: <span id="screen-size">0x0</span></div>
        <div>æ˜¾ç¤ºåŒºåŸŸ: <span id="view-area">0x0</span></div>
        <div>ç‚¹äº‘åç§»: <span id="point-offset">0, 0</span></div>
    </div>

    <!-- FPSæ˜¾ç¤º -->
    <div id="fps-display">
        <span>FPS: </span>
        <span id="fps-value">0</span>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜ -->
    <div id="instructions">
        <div class="instruction-item">
            <span class="instruction-key">æ‹–åŠ¨</span>
            <span>æ—‹è½¬</span>
        </div>
        <div class="instruction-item">
            <span class="instruction-key">ç¼©æ”¾</span>
            <span>è°ƒæ•´è·ç¦»</span>
        </div>
        <div class="instruction-item">
            <span class="instruction-key">åŒå‡»</span>
            <span>é‡ç½®</span>
        </div>
    </div>

    <!-- æ‘„åƒå¤´æƒé™å¼¹çª— -->
    <div id="camera-permission">
        <div class="permission-content">
            <div class="permission-title">äººè„¸ç‚¹äº‘æ£€æµ‹</div>
            <div class="permission-text">
                éœ€è¦è®¿é—®æ‚¨çš„æ‘„åƒå¤´<br>
                æ‰€æœ‰å¤„ç†å‡åœ¨æœ¬åœ°å®Œæˆ
            </div>
            <button id="start-camera">å¼€å§‹æ£€æµ‹</button>
        </div>
    </div>

    <script>
    class FacePointCloudApp {
        constructor() {
            // è®¾å¤‡æ£€æµ‹å’Œåˆ†è¾¨ç‡
            this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            this.screenWidth = window.screen.width;
            this.screenHeight = window.screen.height;
            this.viewportWidth = window.innerWidth;
            this.viewportHeight = window.innerHeight;
            
            // ğŸ¯ å…³é”®ï¼šç‚¹äº‘è‡ªé€‚åº”å‚æ•°
            this.basePointSize = 2.5;
            this.spacingMultiplier = 1.5;
            
            // ğŸ¯ å…³é”®ï¼šç‚¹äº‘å±…ä¸­å‚æ•°
            this.pointCloudOffsetX = 0;    // Xè½´åç§»ï¼Œç”¨äºå±…ä¸­
            this.pointCloudOffsetY = 0;    // Yè½´åç§»ï¼Œç”¨äºå±…ä¸­
            this.pointCloudOffsetZ = 0;    // Zè½´åç§»ï¼Œç”¨äºæ·±åº¦å±…ä¸­
            
            // è‡ªåŠ¨è®¡ç®—ç¼©æ”¾å› å­
            this.calculateScalingFactors();
            
            console.log(`è®¾å¤‡ä¿¡æ¯:
å±å¹•åˆ†è¾¨ç‡: ${this.screenWidth}x${this.screenHeight}
è§†å£å¤§å°: ${this.viewportWidth}x${this.viewportHeight}
ç¼©æ”¾å› å­: ${this.scaleFactor.toFixed(2)}`);
            
            // çŠ¶æ€
            this.isRunning = false;
            this.isPaused = false;
            this.faceDetected = false;
            
            // æ€§èƒ½
            this.frameCount = 0;
            this.lastFpsTime = 0;
            this.fps = 0;
            
            // 3Då‚æ•°
            this.cameraDistance = this.isMobile ? 2.5 : 3.0;
            this.rotationX = 0.0;
            this.rotationY = 0.0;
            this.isDragging = false;
            
            // DOMå…ƒç´ 
            this.canvas = document.getElementById('webgl-canvas');
            this.fpsElement = document.getElementById('fps-value');
            this.screenSizeElement = document.getElementById('screen-size');
            this.viewAreaElement = document.getElementById('view-area');
            this.offsetElement = document.getElementById('point-offset');
            
            // åˆå§‹åŒ–
            this.updateResolutionInfo();
            this.initThreeJS();
            this.initEventListeners();
        }
        
        // è®¡ç®—ç¼©æ”¾å› å­å’Œåç§»é‡
        calculateScalingFactors() {
            // æ ¹æ®å±å¹•åˆ†è¾¨ç‡è®¡ç®—ç¼©æ”¾å› å­
            const diagonal = Math.sqrt(this.screenWidth * this.screenWidth + this.screenHeight * this.screenHeight);
            
            // åŸºäºå¯¹è§’çº¿çš„ç¼©æ”¾å› å­ï¼ˆå•ä½ï¼šåƒç´ /è‹±å¯¸ï¼‰
            if (diagonal > 2000) {
                // å¤§å±è®¾å¤‡ï¼ˆå¹³æ¿ã€ç”µè„‘ï¼‰
                this.scaleFactor = 0.8;
            } else if (diagonal > 1000) {
                // ä¸­ç­‰å±å¹•
                this.scaleFactor = 0.6;
            } else {
                // å°å±è®¾å¤‡ï¼ˆæ‰‹æœºï¼‰
                this.scaleFactor = 0.4;
            }
            
            // è®¡ç®—çºµæ¨ªæ¯”
            this.aspectRatio = this.viewportWidth / this.viewportHeight;
            
            // ğŸ¯ å…³é”®ï¼šè®¡ç®—ç‚¹äº‘åç§»é‡ï¼Œä½¿ç‚¹äº‘å±…ä¸­
            // åŸºäºè§†å£å¤§å°çš„åç§»è®¡ç®—
            if (this.aspectRatio > 1) {
                // æ¨ªå±ï¼šå®½åº¦ > é«˜åº¦
                this.pointCloudOffsetX = 0;  // Xè½´ä¸éœ€è¦åç§»
                this.pointCloudOffsetY = 0.1 * this.aspectRatio;  // æ ¹æ®çºµæ¨ªæ¯”è°ƒæ•´Yåç§»
            } else {
                // ç«–å±ï¼šé«˜åº¦ > å®½åº¦
                this.pointCloudOffsetX = 0;  // Xè½´ä¸éœ€è¦åç§»
                this.pointCloudOffsetY = 0.2 * (1 / this.aspectRatio);  // æ ¹æ®çºµæ¨ªæ¯”è°ƒæ•´Yåç§»
            }
        }
        
        // æ›´æ–°åˆ†è¾¨ç‡ä¿¡æ¯æ˜¾ç¤º
        updateResolutionInfo() {
            this.screenSizeElement.textContent = `${this.screenWidth}x${this.screenHeight}`;
            this.viewAreaElement.textContent = `${this.viewportWidth}x${this.viewportHeight}`;
            this.offsetElement.textContent = `${this.pointCloudOffsetX.toFixed(2)}, ${this.pointCloudOffsetY.toFixed(2)}`;
        }
        
        initThreeJS() {
            try {
                // åœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                
                // ç›¸æœº - æ ¹æ®å±å¹•çºµæ¨ªæ¯”è°ƒæ•´FOV
                const aspect = this.viewportWidth / this.viewportHeight;
                let fov = 45;
                
                // ğŸ¯ æ ¹æ®å±å¹•å¤§å°è°ƒæ•´è§†é‡
                if (this.screenWidth > 1500 || this.screenHeight > 1500) {
                    fov = 35;  // å¤§å±è®¾å¤‡ï¼Œç¼©å°è§†é‡
                } else if (this.screenWidth < 400 || this.screenHeight < 400) {
                    fov = 50;  // å°å±è®¾å¤‡ï¼Œæ‰©å¤§è§†é‡
                }
                
                this.camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
                this.camera.position.set(0, 0, this.cameraDistance);
                
                // æ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: false,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(this.viewportWidth, this.viewportHeight);
                this.renderer.setPixelRatio(1);
                
                // ç‚¹äº‘æè´¨
                this.pointsGeometry = new THREE.BufferGeometry();
                this.pointsMaterial = new THREE.PointsMaterial({
                    size: this.basePointSize,
                    vertexColors: true,
                    sizeAttenuation: false,
                    transparent: false,
                    opacity: 1.0,
                    depthWrite: true,
                    depthTest: true,
                    blending: THREE.NormalBlending
                });
                
                this.points = new THREE.Points(this.pointsGeometry, this.pointsMaterial);
                this.scene.add(this.points);
                
                console.log("âœ… Three.jsåˆå§‹åŒ–å®Œæˆ - è‡ªé€‚åº”å±…ä¸­æ¨¡å¼");
                
            } catch (error) {
                console.error("âŒ Three.jsåˆå§‹åŒ–å¤±è´¥:", error);
                alert("WebGLåˆå§‹åŒ–å¤±è´¥");
            }
        }
        
        initEventListeners() {
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    this.viewportWidth = window.innerWidth;
                    this.viewportHeight = window.innerHeight;
                    
                    this.calculateScalingFactors();
                    this.updateResolutionInfo();
                    
                    this.camera.aspect = this.viewportWidth / this.viewportHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.viewportWidth, this.viewportHeight);
                }, 100);
            });
            
            // è§¦æ‘¸äº‹ä»¶
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastMouseX = e.touches[0].clientX;
                    this.lastMouseY = e.touches[0].clientY;
                    this.touchStartRotation = { x: this.rotationX, y: this.rotationY };
                }
            });
            
            this.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && this.isDragging) {
                    const deltaX = e.touches[0].clientX - this.lastMouseX;
                    const deltaY = e.touches[0].clientY - this.lastMouseY;
                    
                    this.rotationY = this.touchStartRotation.y - deltaX * 0.5;
                    this.rotationX = this.touchStartRotation.x + deltaY * 0.5;
                    this.rotationX = Math.max(-90, Math.min(90, this.rotationX));
                    
                    this.lastMouseX = e.touches[0].clientX;
                    this.lastMouseY = e.touches[0].clientY;
                }
            });
            
            this.canvas.addEventListener('touchend', () => {
                this.isDragging = false;
            });
            
            // é¼ æ ‡äº‹ä»¶
            this.canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!this.isDragging) return;
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.rotationY -= deltaX * 0.5;
                this.rotationX += deltaY * 0.5;
                this.rotationX = Math.max(-90, Math.min(90, this.rotationX));
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                this.isDragging = false;
            });
            
            // æ»šè½®
            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                this.cameraDistance += e.deltaY * 0.005;
                this.cameraDistance = Math.max(1.0, Math.min(10.0, this.cameraDistance));
            });
            
            // åŒå‡»é‡ç½®
            this.canvas.addEventListener('dblclick', () => {
                this.cameraDistance = this.isMobile ? 2.5 : 3.0;
                this.rotationX = 0.0;
                this.rotationY = 0.0;
            });
            
            // å¼€å§‹æŒ‰é’®
            document.getElementById('start-camera').addEventListener('click', () => {
                this.startCamera();
            });
        }
        
        async startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                this.videoElement = document.createElement('video');
                this.videoElement.srcObject = stream;
                this.videoElement.autoplay = true;
                this.videoElement.playsInline = true;
                this.videoElement.muted = true;
                this.videoElement.style.display = 'none';
                document.body.appendChild(this.videoElement);
                
                await new Promise((resolve) => {
                    this.videoElement.onloadedmetadata = () => {
                        this.videoElement.play();
                        resolve();
                    };
                });
                
                document.getElementById('camera-permission').style.display = 'none';
                await this.initMediaPipe();
                this.start();
                
            } catch (error) {
                console.error("æ‘„åƒå¤´è®¿é—®å¤±è´¥:", error);
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´");
            }
        }
        
        async initMediaPipe() {
            this.faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            this.faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            this.faceMesh.onResults(this.handleFaceResults.bind(this));
            
            const processFrame = async () => {
                if (!this.isRunning || this.isPaused || !this.videoElement) return;
                
                try {
                    if (this.videoElement.readyState >= 2) {
                        await this.faceMesh.send({image: this.videoElement});
                    }
                    requestAnimationFrame(processFrame);
                } catch (error) {
                    requestAnimationFrame(processFrame);
                }
            };
            
            this.isRunning = true;
            processFrame();
        }
        
        handleFaceResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                this.faceDetected = false;
                return;
            }
            
            this.faceDetected = true;
            const faceLandmarks = results.multiFaceLandmarks[0];
            this.updatePointCloud(faceLandmarks);
        }
        
        // ğŸ¯ å…³é”®ï¼šæ›´æ–°ç‚¹äº‘ - å®ç°è‡ªé€‚åº”å±…ä¸­
        updatePointCloud(landmarks) {
            if (!landmarks || landmarks.length === 0) return;
            
            const positions = new Float32Array(landmarks.length * 3);
            const colors = new Float32Array(landmarks.length * 3);
            
            // è®¡ç®—ç‚¹äº‘è¾¹ç•Œï¼Œç”¨äºå±…ä¸­
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            // ç¬¬ä¸€éï¼šè®¡ç®—è¾¹ç•Œ
            landmarks.forEach((landmark, index) => {
                const x = (0.5 - landmark.x) * 2.0 * this.spacingMultiplier;
                const y = (0.5 - landmark.y) * 2.0 * this.spacingMultiplier;
                const z = -landmark.z * 1.5 * this.spacingMultiplier;
                
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
                if (z < minZ) minZ = z;
                if (z > maxZ) maxZ = z;
            });
            
            // è®¡ç®—ä¸­å¿ƒç‚¹
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            // è®¡ç®—ç‚¹äº‘å¤§å°
            const cloudWidth = maxX - minX;
            const cloudHeight = maxY - minY;
            const cloudDepth = maxZ - minZ;
            
            // ğŸ¯ è‡ªé€‚åº”ç¼©æ”¾ï¼šæ ¹æ®å±å¹•å¤§å°è°ƒæ•´ç‚¹äº‘å°ºå¯¸
            let adaptiveScale = 1.0;
            
            if (this.screenWidth > 1500) {
                // å¤§å±ï¼šç¼©å°ç‚¹äº‘
                adaptiveScale = 0.7;
            } else if (this.screenWidth < 400) {
                // å°å±ï¼šæ”¾å¤§ç‚¹äº‘
                adaptiveScale = 1.3;
            }
            
            // ğŸ¯ åº”ç”¨è‡ªé€‚åº”å±…ä¸­
            landmarks.forEach((landmark, index) => {
                // åŸå§‹åæ ‡
                let x = (0.5 - landmark.x) * 2.0 * this.spacingMultiplier;
                let y = (0.5 - landmark.y) * 2.0 * this.spacingMultiplier;
                let z = -landmark.z * 1.5 * this.spacingMultiplier;
                
                // ğŸ¯ å…³é”®ï¼šåº”ç”¨å±…ä¸­å˜æ¢
                // 1. ç§»åŠ¨åˆ°åŸç‚¹ï¼ˆå‡å»ä¸­å¿ƒç‚¹ï¼‰
                x -= centerX;
                y -= centerY;
                z -= centerZ;
                
                // 2. æ ¹æ®å±å¹•å¤§å°è‡ªé€‚åº”ç¼©æ”¾
                x *= adaptiveScale * this.scaleFactor;
                y *= adaptiveScale * this.scaleFactor;
                z *= adaptiveScale * this.scaleFactor;
                
                // 3. æ ¹æ®å±å¹•çºµæ¨ªæ¯”åº”ç”¨åç§»ï¼Œä½¿ç‚¹äº‘å§‹ç»ˆå±…ä¸­æ˜¾ç¤º
                x += this.pointCloudOffsetX;
                y += this.pointCloudOffsetY;
                
                positions[index * 3] = x;
                positions[index * 3 + 1] = y;
                positions[index * 3 + 2] = z;
                
                // é¢œè‰²ç¼–ç 
                let color;
                if (index < 17) color = 0x00b4ff;
                else if (index >= 61 && index < 97) color = 0xff3366;
                else if ((index >= 33 && index < 47) || (index >= 263 && index < 277)) color = 0x00ff88;
                else if ((index >= 105 && index < 117) || (index >= 285 && index < 297)) color = 0xffcc00;
                else if ((index >= 168 && index < 198) || [1,2,3,4,5,6].includes(index)) color = 0xff6600;
                else color = 0xcccccc;
                
                colors[index * 3] = ((color >> 16) & 255) / 255;
                colors[index * 3 + 1] = ((color >> 8) & 255) / 255;
                colors[index * 3 + 2] = (color & 255) / 255;
            });
            
            // æ›´æ–°UIæ˜¾ç¤ºç‚¹äº‘åç§»ä¿¡æ¯
            this.offsetElement.textContent = `${this.pointCloudOffsetX.toFixed(2)}, ${this.pointCloudOffsetY.toFixed(2)}`;
            
            if (!this.pointsGeometry.attributes.position) {
                this.pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.pointsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            } else {
                this.pointsGeometry.attributes.position.array = positions;
                this.pointsGeometry.attributes.color.array = colors;
                this.pointsGeometry.attributes.position.needsUpdate = true;
                this.pointsGeometry.attributes.color.needsUpdate = true;
            }
            
            // è®¡ç®—åŒ…å›´çƒï¼Œä¼˜åŒ–æ¸²æŸ“
            this.pointsGeometry.computeBoundingSphere();
        }
        
        animate() {
            const now = performance.now();
            
            // æ›´æ–°FPS
            if (this.lastFpsTime === 0) this.lastFpsTime = now;
            this.frameCount++;
            
            if (now - this.lastFpsTime >= 1000) {
                this.fps = this.frameCount;
                this.frameCount = 0;
                this.lastFpsTime = now;
                this.fpsElement.textContent = Math.round(this.fps);
            }
            
            // æ›´æ–°ç›¸æœºä½ç½®
            const radX = THREE.MathUtils.degToRad(this.rotationX);
            const radY = THREE.MathUtils.degToRad(this.rotationY);
            
            const cameraX = this.cameraDistance * Math.sin(radY) * Math.cos(radX);
            const cameraY = this.cameraDistance * Math.sin(radX);
            const cameraZ = this.cameraDistance * Math.cos(radY) * Math.cos(radX);
            
            this.camera.position.set(cameraX, cameraY, cameraZ);
            this.camera.lookAt(this.pointCloudOffsetX, this.pointCloudOffsetY, 0);
            
            // æ¸²æŸ“
            this.renderer.render(this.scene, this.camera);
            requestAnimationFrame(this.animate.bind(this));
        }
        
        start() {
            this.animate();
        }
    }

    window.addEventListener('DOMContentLoaded', () => {
        new FacePointCloudApp();
    });
    
    // è®¾å¤‡æ–¹å‘å˜åŒ–æ—¶é‡æ–°è®¡ç®—
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            window.location.reload();
        }, 500);
    });
    </script>
</body>
</html>
